package template

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"time"

	"github.com/systmms/dsops/internal/logging"
	"gopkg.in/yaml.v3"
)

// Renderer handles template rendering and file output
type Renderer struct {
	logger *logging.Logger
}

// New creates a new renderer
func New(logger *logging.Logger) *Renderer {
	return &Renderer{
		logger: logger,
	}
}

// RenderOptions configures template rendering
type RenderOptions struct {
	Format      string            // dotenv, json, yaml, template
	Variables   map[string]string // Variables to render
	OutputPath  string            // File path to write to
	Template    string            // Template content (for template format)
	TTL         time.Duration     // Auto-delete after this duration
	Permissions os.FileMode       // File permissions (default 0600)
}

// Render renders variables to the specified format and output
func (r *Renderer) Render(options RenderOptions) error {
	// Set default permissions for security
	if options.Permissions == 0 {
		options.Permissions = 0600 // Read/write for owner only
	}

	// Determine format from file extension if not specified
	if options.Format == "" {
		options.Format = r.detectFormat(options.OutputPath)
	}

	// Render content
	content, err := r.renderContent(options)
	if err != nil {
		return fmt.Errorf("failed to render content: %w", err)
	}

	// Write to file
	if err := r.writeFile(options.OutputPath, content, options.Permissions); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	r.logger.Info("Rendered %d variables to %s (%s format)", 
		len(options.Variables), options.OutputPath, options.Format)

	// Set up auto-deletion if TTL is specified
	if options.TTL > 0 {
		go r.scheduleDelete(options.OutputPath, options.TTL)
		r.logger.Info("File will be auto-deleted in %v", options.TTL)
	}

	return nil
}

// renderContent renders variables according to the specified format
func (r *Renderer) renderContent(options RenderOptions) ([]byte, error) {
	switch options.Format {
	case "dotenv":
		return r.renderDotenv(options.Variables), nil
	case "json":
		return r.renderJSON(options.Variables)
	case "yaml":
		return r.renderYAML(options.Variables)
	case "template":
		return r.renderTemplate(options.Template, options.Variables)
	default:
		return nil, fmt.Errorf("unsupported format: %s", options.Format)
	}
}

// renderDotenv renders variables as a .env file
func (r *Renderer) renderDotenv(variables map[string]string) []byte {
	var buf bytes.Buffer
	
	// Add header comment
	buf.WriteString("# Generated by dsops\n")
	buf.WriteString(fmt.Sprintf("# Created: %s\n", time.Now().Format(time.RFC3339)))
	buf.WriteString("# WARNING: This file contains secrets - do not commit to version control\n\n")

	// Sort keys for consistent output
	keys := make([]string, 0, len(variables))
	for key := range variables {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	// Render each variable
	for _, key := range keys {
		value := variables[key]
		buf.WriteString(fmt.Sprintf("%s=%s\n", key, r.escapeEnvValue(value)))
	}

	return buf.Bytes()
}

// renderJSON renders variables as JSON
func (r *Renderer) renderJSON(variables map[string]string) ([]byte, error) {
	// Create a wrapper object with metadata
	output := map[string]interface{}{
		"generated_at": time.Now().Format(time.RFC3339),
		"generated_by": "dsops",
		"variables":    variables,
	}

	return r.marshalJSON(output)
}

// renderYAML renders variables as YAML
func (r *Renderer) renderYAML(variables map[string]string) ([]byte, error) {
	// Create a wrapper object with metadata
	output := map[string]interface{}{
		"generated_at": time.Now().Format(time.RFC3339),
		"generated_by": "dsops",
		"variables":    variables,
	}

	return yaml.Marshal(output)
}

// renderTemplate renders variables using Go text/template
func (r *Renderer) renderTemplate(templateContent string, variables map[string]string) ([]byte, error) {
	// Create template with helper functions
	tmpl, err := template.New("dsops").Funcs(r.templateFunctions()).Parse(templateContent)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	// Execute template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, variables); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.Bytes(), nil
}

// detectFormat detects output format from file extension
func (r *Renderer) detectFormat(outputPath string) string {
	if outputPath == "" {
		return "dotenv"
	}

	ext := strings.ToLower(filepath.Ext(outputPath))
	switch ext {
	case ".json":
		return "json"
	case ".yaml", ".yml":
		return "yaml"
	case ".env":
		return "dotenv"
	case ".tmpl", ".template":
		return "template"
	default:
		// Check if filename suggests format
		base := strings.ToLower(filepath.Base(outputPath))
		if strings.HasPrefix(base, ".env") {
			return "dotenv"
		}
		return "dotenv" // Default
	}
}

// escapeEnvValue properly escapes a value for .env format
func (r *Renderer) escapeEnvValue(value string) string {
	// If value is simple (no spaces, quotes, etc), return as-is
	if r.isSimpleValue(value) {
		return value
	}

	// Quote and escape the value
	escaped := strings.ReplaceAll(value, "\\", "\\\\") // Escape backslashes
	escaped = strings.ReplaceAll(escaped, "\"", "\\\"") // Escape quotes
	escaped = strings.ReplaceAll(escaped, "\n", "\\n")  // Escape newlines
	escaped = strings.ReplaceAll(escaped, "\r", "\\r")  // Escape carriage returns
	escaped = strings.ReplaceAll(escaped, "\t", "\\t")  // Escape tabs

	return "\"" + escaped + "\""
}

// isSimpleValue checks if a value needs quoting in .env format
func (r *Renderer) isSimpleValue(value string) bool {
	if value == "" {
		return false // Empty values should be quoted
	}

	// Check for characters that require quoting
	needsQuoting := []string{" ", "\t", "\n", "\r", "\"", "'", "#", "=", "$"}
	for _, char := range needsQuoting {
		if strings.Contains(value, char) {
			return false
		}
	}

	return true
}

// writeFile writes content to a file with proper security permissions
func (r *Renderer) writeFile(path string, content []byte, permissions os.FileMode) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write file
	if err := os.WriteFile(path, content, permissions); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// scheduleDelete schedules a file for deletion after the specified TTL
func (r *Renderer) scheduleDelete(path string, ttl time.Duration) {
	timer := time.NewTimer(ttl)
	defer timer.Stop()

	<-timer.C

	if err := os.Remove(path); err != nil {
		r.logger.Error("Failed to auto-delete file %s: %v", path, err)
	} else {
		r.logger.Info("Auto-deleted file %s", path)
	}
}

// templateFunctions returns helper functions for Go templates
func (r *Renderer) templateFunctions() template.FuncMap {
	return template.FuncMap{
		// Environment variable access
		"env": func(key string) string {
			return os.Getenv(key)
		},
		
		// Check if key exists
		"has": func(key string, m map[string]string) bool {
			_, exists := m[key]
			return exists
		},

		// JSON helpers
		"json": func(v interface{}) (string, error) {
			bytes, err := r.marshalJSON(v)
			return string(bytes), err
		},

		// Base64 encoding/decoding
		"b64enc": func(s string) string {
			return r.base64Encode(s)
		},
		"b64dec": func(s string) (string, error) {
			return r.base64Decode(s)
		},

		// String manipulation
		"quote": func(s string) string {
			return strconv.Quote(s)
		},
		"indent": func(spaces int, s string) string {
			return r.indent(s, strings.Repeat(" ", spaces))
		},
		"nindent": func(spaces int, s string) string {
			return "\n" + r.indent(s, strings.Repeat(" ", spaces))
		},

		// Hashing
		"sha256": func(s string) string {
			return r.sha256Hash(s)
		},
	}
}