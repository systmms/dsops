package template

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/systmms/dsops/internal/logging"
)

func createTestRenderer() *Renderer {
	logger := logging.New(false, true)
	return New(logger)
}

func TestNew(t *testing.T) {
	t.Parallel()
	logger := logging.New(false, true)
	renderer := New(logger)
	assert.NotNil(t, renderer)
	assert.Equal(t, logger, renderer.logger)
}

func TestRenderer_detectFormat(t *testing.T) {
	t.Parallel()

	renderer := createTestRenderer()

	tests := []struct {
		name     string
		path     string
		expected string
	}{
		{"json_extension", "output.json", "json"},
		{"yaml_extension", "output.yaml", "yaml"},
		{"yml_extension", "output.yml", "yaml"},
		{"env_extension", "output.env", "dotenv"},
		{"tmpl_extension", "output.tmpl", "template"},
		{"template_extension", "output.template", "template"},
		{"env_prefix", ".env.production", "dotenv"},
		{"env_local", ".env.local", "dotenv"},
		{"unknown_extension", "output.txt", "dotenv"},
		{"no_extension", "envfile", "dotenv"},
		{"empty_path", "", "dotenv"},
		{"uppercase", "OUTPUT.JSON", "json"},
		{"mixed_case", "Output.YaML", "yaml"},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			result := renderer.detectFormat(tt.path)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestRenderer_isSimpleValue(t *testing.T) {
	t.Parallel()

	renderer := createTestRenderer()

	tests := []struct {
		name     string
		value    string
		expected bool
	}{
		{"simple_string", "simplevalue", true},
		{"numeric", "12345", true},
		{"alphanumeric", "value123", true},
		{"underscore", "my_value", true},
		{"hyphen", "my-value", true},
		{"empty_string", "", false},
		{"with_space", "has space", false},
		{"with_tab", "has\ttab", false},
		{"with_newline", "has\nnewline", false},
		{"with_carriage_return", "has\rreturn", false},
		{"with_double_quote", `has"quote`, false},
		{"with_single_quote", "has'quote", false},
		{"with_hash", "has#comment", false},
		{"with_equals", "key=value", false},
		{"with_dollar", "has$var", false},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			result := renderer.isSimpleValue(tt.value)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestRenderer_escapeEnvValue(t *testing.T) {
	t.Parallel()

	renderer := createTestRenderer()

	tests := []struct {
		name     string
		value    string
		expected string
	}{
		{"simple", "simple", "simple"},
		{"with_space", "has space", `"has space"`},
		{"with_newline", "line1\nline2", `"line1\nline2"`},
		{"with_tab", "col1\tcol2", `"col1\tcol2"`},
		{"with_quote", `has"quote`, `"has\"quote"`},
		{"with_backslash", `path\to\file`, `path\to\file`},
		{"complex", "value with\nmultiple\n\"special\" chars", `"value with\nmultiple\n\"special\" chars"`},
		{"empty", "", `""`},
		{"with_carriage_return", "line1\rline2", `"line1\rline2"`},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			result := renderer.escapeEnvValue(tt.value)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestRenderer_renderDotenv(t *testing.T) {
	t.Parallel()

	renderer := createTestRenderer()

	tests := []struct {
		name      string
		variables map[string]string
		checks    []string
	}{
		{
			name: "single_variable",
			variables: map[string]string{
				"DATABASE_URL": "postgres://localhost/db",
			},
			checks: []string{
				"DATABASE_URL=postgres://localhost/db",
				"# Generated by dsops",
			},
		},
		{
			name: "multiple_variables_sorted",
			variables: map[string]string{
				"ZOO":   "zebra",
				"ALPHA": "first",
				"BETA":  "second",
			},
			checks: []string{
				"ALPHA=first",
				"BETA=second",
				"ZOO=zebra",
			},
		},
		{
			name: "values_needing_escaping",
			variables: map[string]string{
				"COMPLEX": "value with spaces",
			},
			checks: []string{
				`COMPLEX="value with spaces"`,
			},
		},
		{
			name:      "empty_variables",
			variables: map[string]string{},
			checks: []string{
				"# Generated by dsops",
			},
		},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			result := renderer.renderDotenv(tt.variables)
			resultStr := string(result)

			for _, check := range tt.checks {
				assert.Contains(t, resultStr, check)
			}
			// Should contain timestamp comment
			assert.Contains(t, resultStr, "# Created:")
			// Should contain warning
			assert.Contains(t, resultStr, "WARNING: This file contains secrets")
		})
	}
}

func TestRenderer_renderJSON(t *testing.T) {
	t.Parallel()

	renderer := createTestRenderer()

	tests := []struct {
		name      string
		variables map[string]string
		checks    []string
	}{
		{
			name: "single_variable",
			variables: map[string]string{
				"API_KEY": "secret123",
			},
			checks: []string{
				`"generated_by"`,
				`"dsops"`,
				`"variables"`,
				`"API_KEY"`,
				`"secret123"`,
			},
		},
		{
			name: "multiple_variables",
			variables: map[string]string{
				"KEY1": "value1",
				"KEY2": "value2",
			},
			checks: []string{
				`"KEY1"`,
				`"value1"`,
				`"KEY2"`,
				`"value2"`,
			},
		},
		{
			name:      "empty_variables",
			variables: map[string]string{},
			checks: []string{
				`"generated_by"`,
				`"variables"`,
			},
		},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			result, err := renderer.renderJSON(tt.variables)
			require.NoError(t, err)

			resultStr := string(result)
			for _, check := range tt.checks {
				assert.Contains(t, resultStr, check)
			}
			assert.Contains(t, resultStr, "generated_at")
		})
	}
}

func TestRenderer_renderYAML(t *testing.T) {
	t.Parallel()

	renderer := createTestRenderer()

	tests := []struct {
		name      string
		variables map[string]string
		checks    []string
	}{
		{
			name: "single_variable",
			variables: map[string]string{
				"DATABASE_PASSWORD": "mysecret",
			},
			checks: []string{
				"generated_by: dsops",
				"DATABASE_PASSWORD: mysecret",
			},
		},
		{
			name: "multiple_variables",
			variables: map[string]string{
				"VAR1": "val1",
				"VAR2": "val2",
			},
			checks: []string{
				"VAR1: val1",
				"VAR2: val2",
			},
		},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			result, err := renderer.renderYAML(tt.variables)
			require.NoError(t, err)

			resultStr := string(result)
			for _, check := range tt.checks {
				assert.Contains(t, resultStr, check)
			}
			assert.Contains(t, resultStr, "generated_at")
		})
	}
}

func TestRenderer_renderTemplate(t *testing.T) {
	t.Parallel()

	renderer := createTestRenderer()

	tests := []struct {
		name      string
		template  string
		variables map[string]string
		expected  string
		wantErr   bool
	}{
		{
			name:     "simple_substitution",
			template: "DB={{ .DATABASE_URL }}",
			variables: map[string]string{
				"DATABASE_URL": "postgres://localhost/db",
			},
			expected: "DB=postgres://localhost/db",
			wantErr:  false,
		},
		{
			name:     "multiple_substitutions",
			template: "export DB={{ .DB }}\nexport API={{ .API }}",
			variables: map[string]string{
				"DB":  "localhost",
				"API": "http://api.example.com",
			},
			expected: "export DB=localhost\nexport API=http://api.example.com",
			wantErr:  false,
		},
		{
			name:     "with_has_function",
			template: "{{ if has \"KEY\" . }}KEY exists{{ end }}",
			variables: map[string]string{
				"KEY": "value",
			},
			expected: "KEY exists",
			wantErr:  false,
		},
		{
			name:      "invalid_template_syntax",
			template:  "{{ .Missing",
			variables: map[string]string{},
			expected:  "",
			wantErr:   true,
		},
		{
			name:      "missing_key_returns_no_value",
			template:  "Value={{ .MISSING }}",
			variables: map[string]string{},
			expected:  "Value=<no value>",
			wantErr:   false,
		},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			result, err := renderer.renderTemplate(tt.template, tt.variables)

			if tt.wantErr {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)
			assert.Equal(t, tt.expected, string(result))
		})
	}
}

func TestRenderer_renderContent(t *testing.T) {
	t.Parallel()

	renderer := createTestRenderer()

	tests := []struct {
		name    string
		options RenderOptions
		wantErr bool
		errMsg  string
	}{
		{
			name: "dotenv_format",
			options: RenderOptions{
				Format:    "dotenv",
				Variables: map[string]string{"KEY": "value"},
			},
			wantErr: false,
		},
		{
			name: "json_format",
			options: RenderOptions{
				Format:    "json",
				Variables: map[string]string{"KEY": "value"},
			},
			wantErr: false,
		},
		{
			name: "yaml_format",
			options: RenderOptions{
				Format:    "yaml",
				Variables: map[string]string{"KEY": "value"},
			},
			wantErr: false,
		},
		{
			name: "template_format",
			options: RenderOptions{
				Format:    "template",
				Template:  "{{ .KEY }}",
				Variables: map[string]string{"KEY": "value"},
			},
			wantErr: false,
		},
		{
			name: "unsupported_format",
			options: RenderOptions{
				Format:    "unknown",
				Variables: map[string]string{"KEY": "value"},
			},
			wantErr: true,
			errMsg:  "unsupported format",
		},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			result, err := renderer.renderContent(tt.options)

			if tt.wantErr {
				assert.Error(t, err)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
				return
			}

			require.NoError(t, err)
			assert.NotEmpty(t, result)
		})
	}
}

func TestRenderer_writeFile(t *testing.T) {
	t.Parallel()

	renderer := createTestRenderer()

	t.Run("writes_file_with_permissions", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "output.env")
		content := []byte("KEY=value\n")

		err := renderer.writeFile(filePath, content, 0600)
		require.NoError(t, err)

		// Verify file exists and has correct content
		data, err := os.ReadFile(filePath)
		require.NoError(t, err)
		assert.Equal(t, content, data)

		// Verify permissions
		info, err := os.Stat(filePath)
		require.NoError(t, err)
		assert.Equal(t, os.FileMode(0600), info.Mode().Perm())
	})

	t.Run("creates_parent_directories", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "nested", "dir", "output.env")
		content := []byte("KEY=value\n")

		err := renderer.writeFile(filePath, content, 0600)
		require.NoError(t, err)

		// Verify file exists
		assert.FileExists(t, filePath)
	})

	t.Run("overwrites_existing_file", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "output.env")

		// Write initial content
		err := os.WriteFile(filePath, []byte("OLD=value"), 0644)
		require.NoError(t, err)

		// Overwrite
		newContent := []byte("NEW=value\n")
		err = renderer.writeFile(filePath, newContent, 0600)
		require.NoError(t, err)

		data, err := os.ReadFile(filePath)
		require.NoError(t, err)
		assert.Equal(t, newContent, data)
	})
}

func TestRenderer_Render(t *testing.T) {
	t.Parallel()

	renderer := createTestRenderer()

	t.Run("renders_dotenv_to_file", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "output.env")

		options := RenderOptions{
			Format: "dotenv",
			Variables: map[string]string{
				"DATABASE_URL": "postgres://localhost/db",
				"API_KEY":      "secret123",
			},
			OutputPath: filePath,
		}

		err := renderer.Render(options)
		require.NoError(t, err)

		// Verify file was created
		assert.FileExists(t, filePath)

		// Verify content
		data, err := os.ReadFile(filePath)
		require.NoError(t, err)
		content := string(data)
		assert.Contains(t, content, "DATABASE_URL=postgres://localhost/db")
		assert.Contains(t, content, "API_KEY=secret123")

		// Verify default permissions
		info, err := os.Stat(filePath)
		require.NoError(t, err)
		assert.Equal(t, os.FileMode(0600), info.Mode().Perm())
	})

	t.Run("auto_detects_format_from_extension", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "output.json")

		options := RenderOptions{
			Variables: map[string]string{
				"KEY": "value",
			},
			OutputPath: filePath,
		}

		err := renderer.Render(options)
		require.NoError(t, err)

		// Verify it rendered as JSON
		data, err := os.ReadFile(filePath)
		require.NoError(t, err)
		assert.Contains(t, string(data), `"variables"`)
	})

	t.Run("uses_custom_permissions", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "output.env")

		options := RenderOptions{
			Format:      "dotenv",
			Variables:   map[string]string{"KEY": "value"},
			OutputPath:  filePath,
			Permissions: 0640,
		}

		err := renderer.Render(options)
		require.NoError(t, err)

		info, err := os.Stat(filePath)
		require.NoError(t, err)
		assert.Equal(t, os.FileMode(0640), info.Mode().Perm())
	})

	t.Run("returns_error_for_invalid_template", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "output.txt")

		options := RenderOptions{
			Format:     "template",
			Template:   "{{ .Invalid",
			Variables:  map[string]string{},
			OutputPath: filePath,
		}

		err := renderer.Render(options)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to render content")
	})
}

func TestRenderer_templateFunctions(t *testing.T) {
	// Not parallel because some subtests use t.Setenv
	renderer := createTestRenderer()
	funcs := renderer.templateFunctions()

	t.Run("has_function", func(t *testing.T) {
		t.Parallel()
		hasFn := funcs["has"].(func(string, map[string]string) bool)

		m := map[string]string{"KEY": "value"}
		assert.True(t, hasFn("KEY", m))
		assert.False(t, hasFn("MISSING", m))
	})

	t.Run("quote_function", func(t *testing.T) {
		t.Parallel()
		quoteFn := funcs["quote"].(func(string) string)

		result := quoteFn("test")
		assert.Equal(t, `"test"`, result)

		result = quoteFn(`with"quote`)
		assert.Contains(t, result, `\"`)
	})

	t.Run("env_function", func(t *testing.T) {
		// Not parallel because t.Setenv can't be used with t.Parallel()
		envFn := funcs["env"].(func(string) string)

		// Set a test env var
		t.Setenv("TEST_RENDER_VAR", "testvalue")

		result := envFn("TEST_RENDER_VAR")
		assert.Equal(t, "testvalue", result)

		// Non-existent returns empty
		result = envFn("NONEXISTENT_VAR_12345")
		assert.Equal(t, "", result)
	})

	t.Run("b64enc_function", func(t *testing.T) {
		t.Parallel()
		b64encFn := funcs["b64enc"].(func(string) string)

		result := b64encFn("hello")
		assert.Equal(t, "aGVsbG8=", result)
	})

	t.Run("b64dec_function", func(t *testing.T) {
		t.Parallel()
		b64decFn := funcs["b64dec"].(func(string) (string, error))

		result, err := b64decFn("aGVsbG8=")
		require.NoError(t, err)
		assert.Equal(t, "hello", result)

		// Invalid base64
		_, err = b64decFn("invalid!!")
		assert.Error(t, err)
	})

	t.Run("indent_function", func(t *testing.T) {
		t.Parallel()
		indentFn := funcs["indent"].(func(int, string) string)

		result := indentFn(2, "line1\nline2")
		assert.Equal(t, "  line1\n  line2", result)
	})

	t.Run("nindent_function", func(t *testing.T) {
		t.Parallel()
		nindentFn := funcs["nindent"].(func(int, string) string)

		result := nindentFn(4, "line1\nline2")
		assert.True(t, strings.HasPrefix(result, "\n"))
		assert.Contains(t, result, "    line1")
	})

	t.Run("sha256_function", func(t *testing.T) {
		t.Parallel()
		sha256Fn := funcs["sha256"].(func(string) string)

		result := sha256Fn("test")
		// SHA256 of "test" is known
		assert.Equal(t, "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08", result)
	})
}

func TestRenderer_scheduleDelete(t *testing.T) {
	// This test verifies TTL-based file deletion
	// Note: We test this separately because it uses goroutines
	t.Run("deletes_file_after_ttl", func(t *testing.T) {
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "todelete.env")

		// Create file
		err := os.WriteFile(filePath, []byte("content"), 0600)
		require.NoError(t, err)

		renderer := createTestRenderer()

		// Schedule deletion with short TTL
		go renderer.scheduleDelete(filePath, 100*time.Millisecond)

		// Verify file exists initially
		assert.FileExists(t, filePath)

		// Wait for deletion
		time.Sleep(200 * time.Millisecond)

		// Verify file was deleted
		_, err = os.Stat(filePath)
		assert.True(t, os.IsNotExist(err))
	})
}

func TestRenderOptions_defaults(t *testing.T) {
	t.Parallel()

	t.Run("default_permissions_are_secure", func(t *testing.T) {
		t.Parallel()
		tmpDir := t.TempDir()
		filePath := filepath.Join(tmpDir, "output.env")

		renderer := createTestRenderer()
		options := RenderOptions{
			Variables:  map[string]string{"KEY": "value"},
			OutputPath: filePath,
			// Permissions not set
		}

		err := renderer.Render(options)
		require.NoError(t, err)

		info, err := os.Stat(filePath)
		require.NoError(t, err)
		// Should default to 0600
		assert.Equal(t, os.FileMode(0600), info.Mode().Perm())
	})
}
